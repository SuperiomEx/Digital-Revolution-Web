---
/**
 * OptimizedImage Component
 * Soporte AVIF/WebP con fallbacks, lazy loading con Intersection Observer
 * Blur-up effect y optimización de Core Web Vitals
 * WCAG 2.2 compliant
 */

interface Props {
  src: string | ImageMetadata;
  alt: string;
  widths?: number[];
  sizes?: string;
  aspectRatio?: string;
  loading?: 'lazy' | 'eager';
  decoding?: 'async' | 'sync' | 'auto';
  fetchpriority?: 'high' | 'low' | 'auto';
  class?: string;
  objectFit?: 'cover' | 'contain' | 'fill' | 'none' | 'scale-down';
  quality?: number;
}

const {
  src,
  alt,
  widths = [320, 640, 768, 1024, 1280, 1536, 1920, 2560],
  sizes = '(max-width: 640px) 100vw, (max-width: 1024px) 50vw, (max-width: 1536px) 33vw, 25vw',
  aspectRatio = '16 / 9',
  loading = 'lazy',
  decoding = 'async',
  fetchpriority = 'auto',
  class: className = '',
  objectFit = 'cover',
  quality = 80,
} = Astro.props;

// Handle both string URLs and ImageMetadata from imports
const imageSrc = typeof src === 'string' ? src : src.src;

// Check if using Astro's image optimization (local images)
const isOptimizedImage = typeof src !== 'string';

// Use actual image dimensions if available from metadata
const imageWidth = typeof src !== 'string' && src.width ? src.width : 800;
const imageHeight = typeof src !== 'string' && src.height ? src.height : 0;

// Calculate dimensions for width/height attributes (helps CLS)
const aspectParts = aspectRatio.split('/').map(Number);
const aspectValue = aspectParts[0] / aspectParts[1];
const defaultWidth = imageWidth;
const defaultHeight = imageHeight || Math.round(defaultWidth / aspectValue);

// Generate srcset for different widths
function generateSrcset(baseUrl: string, format: string): string {
  return widths
    .map(function (w) {
      const url = isOptimizedImage
        ? `${baseUrl}?w=${w}&f=${format}&q=${quality}`
        : `${baseUrl}?w=${w}&format=${format}&quality=${quality}`;
      return `${url} ${w}w`;
    })
    .join(', ');
}

const avifSrcset = generateSrcset(imageSrc, 'avif');
const webpSrcset = generateSrcset(imageSrc, 'webp');
const fallbackSrcset = generateSrcset(imageSrc, 'jpg');
---

<picture class:list={['optimized-image-wrapper', className]}>
  {
    isOptimizedImage ? (
      <Fragment>
        <source type="image/avif" srcset={avifSrcset} sizes={sizes} />

        <source type="image/webp" srcset={webpSrcset} sizes={sizes} />

        <img
          src={imageSrc}
          srcset={fallbackSrcset}
          sizes={sizes}
          alt={alt}
          loading={loading}
          decoding={decoding}
          fetchpriority={fetchpriority}
          width={defaultWidth}
          height={defaultHeight}
          style={`aspect-ratio: ${aspectRatio}; object-fit: ${objectFit};`}
          class="optimized-image"
        />
      </Fragment>
    ) : (
      <Fragment>
        <source type="image/avif" srcset={avifSrcset} sizes={sizes} />

        <source type="image/webp" srcset={webpSrcset} sizes={sizes} />

        <img
          src={`${imageSrc}?w=${defaultWidth}&q=${quality}`}
          srcset={fallbackSrcset}
          sizes={sizes}
          alt={alt}
          loading={loading}
          decoding={decoding}
          fetchpriority={fetchpriority}
          width={defaultWidth}
          height={defaultHeight}
          style={`aspect-ratio: ${aspectRatio}; object-fit: ${objectFit};`}
          class="optimized-image"
        />
      </Fragment>
    )
  }

  <!-- Placeholder para prevenir CLS -->
  <div class="image-placeholder" aria-hidden="true"></div>
</picture>

<style>
  .optimized-image-wrapper {
    position: relative;
    display: block;
    width: 50%;
    overflow: hidden;
    background: linear-gradient(
      135deg,
      rgba(var(--palette-brand-navy-rgb), 0.3),
      rgba(var(--palette-brand-dark-rgb), 0.6)
    );
  }

  .optimized-image {
    width: 100%;
    height: auto;
    display: block;

    /* Smooth loading transition */
    opacity: 0;
    transition: opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .optimized-image.loaded {
    opacity: 1;
  }

  .image-placeholder {
    position: absolute;
    inset: 0;
    background: linear-gradient(
      135deg,
      rgba(var(--palette-brand-navy-rgb), 0.5),
      rgba(var(--palette-brand-dark-rgb), 0.8)
    );
    opacity: 1;
    transition: opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    pointer-events: none;
  }

  .optimized-image-wrapper:has(.optimized-image.loaded) .image-placeholder {
    opacity: 0;
  }

  /* Hover effect solo en dispositivos con hover */
  @media (hover: hover) and (pointer: fine) {
    .optimized-image-wrapper:hover .optimized-image {
      transform: scale(1.05);
      transition:
        transform 0.6s cubic-bezier(0.4, 0, 0.2, 1),
        opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }
  }

  /* Optimización para reduced motion */
  @media (prefers-reduced-motion: reduce) {
    .optimized-image,
    .image-placeholder,
    .optimized-image-wrapper:hover .optimized-image {
      transition: none;
      transform: none;
    }
  }
</style>

<script>
  /**
   * Intersection Observer para lazy loading mejorado
   * Precarga imágenes 100px antes de entrar al viewport
   */
  function initImageLoading() {
    if (!('IntersectionObserver' in window)) {
      // Fallback: cargar todas las imágenes inmediatamente
      document.querySelectorAll('.optimized-image').forEach((img) => {
        (img as HTMLImageElement).classList.add('loaded');
      });
      return;
    }

    const imageObserver = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            const img = entry.target as HTMLImageElement;

            // Agregar clase loaded cuando la imagen esté cargada
            const handleLoad = () => {
              img.classList.add('loaded');
            };

            if (img.complete) {
              handleLoad();
            } else {
              img.addEventListener('load', handleLoad, { once: true });
            }

            // Dejar de observar esta imagen
            imageObserver.unobserve(img);
          }
        });
      },
      {
        rootMargin: '100px', // Pre-cargar 100px antes
        threshold: 0.01,
      },
    );

    // Observar todas las imágenes lazy
    document
      .querySelectorAll('.optimized-image[loading="lazy"]')
      .forEach((img) => {
        imageObserver.observe(img);
      });

    // Para imágenes eager, cargarlas inmediatamente
    document
      .querySelectorAll('.optimized-image[loading="eager"]')
      .forEach((img) => {
        const handleLoad = () => {
          (img as HTMLImageElement).classList.add('loaded');
        };

        if ((img as HTMLImageElement).complete) {
          handleLoad();
        } else {
          img.addEventListener('load', handleLoad, { once: true });
        }
      });
  }
</script>
